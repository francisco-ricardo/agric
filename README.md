# üå± Agric API ‚Äì Gest√£o de Produtores Rurais

![Build](https://img.shields.io/badge/build-passing-brightgreen)
![Coverage](https://img.shields.io/badge/coverage-97%25-brightgreen)
![License](https://img.shields.io/badge/license-MIT-blue)
![Python](https://img.shields.io/badge/python-3.12%2B-blue)
![Django](https://img.shields.io/badge/Django-5.2-green?logo=django)
![Docker](https://img.shields.io/badge/docker-ready-blue?logo=docker)
![Docker Compose](https://img.shields.io/badge/docker--compose-ready-blue?logo=docker)
![Dev Container](https://img.shields.io/badge/devcontainer-ready-brightgreen?logo=visualstudiocode)
![Makefile](https://img.shields.io/badge/Makefile-automation-blue)
![OpenAPI](https://img.shields.io/badge/OpenAPI-3.0-blue)
![REST Level 2](https://img.shields.io/badge/REST%20Maturity-Level%202-blue)
![AWS Deploy](https://img.shields.io/badge/aws-em%20teste-blue?logo=amazon-aws)

> :rocket: Projeto em teste na AWS! [Acesse aqui](http://44.207.252.93:8000/api/docs)

> API RESTful para cadastro, gest√£o e an√°lise de produtores rurais, propriedades, culturas e safras. 
Desenvolvida com Django, Docker e PostgreSQL, seguindo as melhores pr√°ticas de Clean Code, SOLID, KISS e TDD, com foco em backend para o desafio t√©cnico *Brain Agriculture ‚Äì Teste T√©cnico V2*.

---

## ‚ú® Vis√£o Geral

O Agric API √© uma solu√ß√£o robusta para o gerenciamento de produtores rurais, propriedades, culturas plantadas e safras, com valida√ß√µes de neg√≥cio, dashboard consolidado e documenta√ß√£o OpenAPI interativa.

---

## üìã Funcionalidades

- Cadastro, edi√ß√£o e exclus√£o de produtores rurais (CPF/CNPJ).
- Gest√£o de propriedades, cidades, estados, tipos de cultura e culturas plantadas por safra.
- Valida√ß√µes autom√°ticas de CPF/CNPJ e √°reas das propriedades.
- Dashboard consolidado com estat√≠sticas e agrupamentos.
- API RESTful documentada (Swagger/OpenAPI).
- Testes unit√°rios e de integra√ß√£o (TDD).
- Observabilidade via logs estruturados.

---

## üèóÔ∏è Arquitetura

- **Backend:** Django + Django REST Framework
- **Banco de Dados:** PostgreSQL
- **Containeriza√ß√£o:** Docker
- **Testes:** Pytest, DRF Test, cobertura automatizada
- **Documenta√ß√£o:** OpenAPI/Swagger
- **Observabilidade:** Logging estruturado, pronto para integra√ß√£o com ferramentas de monitoramento

---

## üóÇÔ∏è Modelagem de Dados

![Diagrama DER](docs/der.png)

---

## üöÄ Como rodar o projeto

### 1. Clone o reposit√≥rio

```bash
git clone git@github.com:francisco-ricardo/agric.git
cd agric
```

### 2. Configure as vari√°veis de ambiente

Crie um arquivo .env no diret√≥rio raiz, definindo os seguintes valores:

| Vari√°vel              | Valor sugerido (exemplo)           | Descri√ß√£o                                 |
|-----------------------|------------------------------------|-------------------------------------------|
| DJANGO_READ_DOTENV    | 1                                  | Carrega vari√°veis do .env                 |
| DEBUG                 | 1                                  | 1 para dev, 0 para produ√ß√£o               |
| DJANGO_LOG_LEVEL      | INFO                               | N√≠vel de log (INFO, WARNING, ERROR, etc.) |
| POSTGRES_HOST         | agric_db                           | Host do banco PostgreSQL                  |
| POSTGRES_PORT         | 5432                               | Porta do banco PostgreSQL                 |
| POSTGRES_DB           | agricdb                            | Nome do banco PostgreSQL                  |
| POSTGRES_USER         | agric                              | Usu√°rio do banco PostgreSQL               |
| POSTGRES_PASSWORD     | sua_senha_segura                   | Senha do banco PostgreSQL                 |
| ALLOWED_HOSTS         | seu.dominio.com,localhost,127.0.0.1| Hosts permitidos (separados por v√≠rgula)  |
| SECRET_KEY            | sua-chave-secreta                  | Chave secreta do Django                   |
| DJANGO_DB_DISABLE_SSL | 1                                  | Desabilita SSL na conex√£o com o BD local  |

### 3. Suba o ambiente de desenvolvimento

Use o Makefile para facilitar:

```bash
make up
```
Isso ir√° construir as imagens e subir os containers da API e do banco de dados em background.

### 4. Crie o banco de dados (se necess√°rio)

```bash
make createdb
```

### 5. Aplique as migra√ß√µes

```bash
make migrate
```

### 6. (Opcional) Popule o banco com dados iniciais

```bash
make seed
```

### 7. Acesse a aplica√ß√£o

O servidor estar√° dispon√≠vel em [http://localhost:8000](http://localhost:8000).

Exemplos:

- http://localhost:8000/api/dashboard/
- http://localhost:8000/api/produtores/
- http://localhost:8000/api/docs/
- http://localhost:8000/api/redoc/


### 8. Para parar o ambiente

```bash
make down
```

### 9. Para ver todos os comandos dispon√≠veis

```bash
make help
```

---

## üìë Exemplos de Payloads

### Produtor

- **POST /api/produtores/**
```json
{
  "cpf_cnpj": "12345678901",
  "nome_produtor": "Jo√£o Silva",
  "tipo_documento": "CPF"
}
```

- **GET /api/produtores/12345678901/**
```json
{
  "cpf_cnpj": "12345678901",
  "nome_produtor": "Jo√£o Silva",
  "tipo_documento": "CPF"
}
```

### Propriedade

- **POST /api/propriedades/**
```json
{
  "nome_propriedade": "Fazenda Boa Vista",
  "area_total": 100.0,
  "area_agricultavel": 80.0,
  "area_vegetacao": 20.0,
  "cidade": 1,
  "produtor": "12345678901"
}
```

### Cultura

- **POST /api/culturas/**
```json
{
  "ano_safra": 2024,
  "tipo_cultura": 1,
  "propriedade": 1
}
```

### Dashboard

Retorna:
- Total de fazendas cadastradas
- Total de hectares registrados
- Gr√°ficos de pizza: por estado, por cultura plantada, por uso do solo

- **GET /api/dashboard/**
```json
{
  "total_fazendas": 3,
  "total_hectares": 250.5,
  "fazendas_por_estado": [
    {"nome_estado": "Minas Gerais", "qtd_fazendas": 2, "total_hectares": 180.0},
    {"nome_estado": "S√£o Paulo", "qtd_fazendas": 1, "total_hectares": 70.5}
  ],
  "culturas_plantadas": [
    {"tipo_cultura": "Gr√£os", "qtd": 2},
    {"tipo_cultura": "Frutas", "qtd": 1}
  ],
  "uso_do_solo": {
    "total_agricultavel": 200.0,
    "total_vegetacao": 50.5
  }
}
```

---

## üß™ Testes e Cobertura

- Testes unit√°rios e de integra√ß√£o automatizados com Pytest e DRF Test.
- **Cobertura de testes: 97%**  
  O projeto possui cobertura de testes medida com `pytest --cov`, abrangendo:
  - Todos os fluxos de neg√≥cio cr√≠ticos
  - Valida√ß√µes de regras de neg√≥cio e erros esperados
  - Casos de borda e cen√°rios de falha
  - Testes de integra√ß√£o ponta a ponta dos principais endpoints
- Para visualizar o relat√≥rio de cobertura em HTML:
  ```bash
  make cov
  # Abra o arquivo htmlcov/index.html no navegador
  ```

---

## üìë Documenta√ß√£o OpenAPI

Acesse a documenta√ß√£o completa, com exemplos de payloads, descri√ß√µes e contratos de todos os endpoints em `/api/docs/` (Swagger) ou `/api/redoc/`.

---

## üõ°Ô∏è Observabilidade

- Logs estruturados para todas as opera√ß√µes cr√≠ticas e erros.
- Pronto para integra√ß√£o com Railway, AWS CloudWatch, Sentry, etc.

---

## üí° Diferenciais T√©cnicos

- **Clean Code, SOLID, KISS:** C√≥digo limpo, modular e f√°cil de manter.
- **TDD:** Testes desde o in√≠cio, garantindo qualidade e seguran√ßa.
- **OpenAPI:** Contrato de API claro, facilitando integra√ß√£o e manuten√ß√£o.
- **Pronto para produ√ß√£o:** Docker, logs, vari√°veis de ambiente, deploy em nuvem.

---

## üèÖ N√≠vel de Maturidade REST

Esta API segue o **N√≠vel 2 do Richardson Maturity Model**:

- Recursos bem definidos e URLs sem√¢nticas.
- Uso correto dos verbos HTTP (GET, POST, PUT/PATCH, DELETE).
- Retorno de status HTTP apropriados para cada opera√ß√£o.
- Contratos claros e documenta√ß√£o OpenAPI.
- (Ainda n√£o implementa HATEOAS, que caracteriza o n√≠vel 3.)

---

## üîí Seguran√ßa

O projeto implementa algumas pr√°ticas de seguran√ßa:

- **Valida√ß√£o rigorosa de dados:** CPF/CNPJ validados, regras de neg√≥cio garantidas por serializers e m√©todos `clean` nos models, valida√ß√£o de √°reas das propriedades.

- **Preven√ß√£o de inje√ß√£o de SQL:** Uso exclusivo do ORM do Django.

- **Headers de seguran√ßa:** Middlewares padr√£o do Django (`SecurityMiddleware`, `XFrameOptionsMiddleware`) ativos.

- **Tratamento padronizado de erros:** Respostas HTTP apropriadas, sem exposi√ß√£o de detalhes sens√≠veis.

- **Logs estruturados:** Todas as opera√ß√µes cr√≠ticas e erros s√£o registrados para auditoria e monitoramento.

- **Cobertura de testes:** Testes automatizados garantem que regras de neg√≥cio e valida√ß√µes de seguran√ßa n√£o sejam quebradas.

- **Documenta√ß√£o OpenAPI:** Contrato de API claro, reduzindo riscos de uso incorreto.

**Nota:** Para facilitar o acesso, testes e avalia√ß√£o t√©cnica, **esta API est√° aberta e n√£o exige autentica√ß√£o JWT ou OAuth2**. Isso foi uma decis√£o consciente, alinhada aos requisitos do desafio e ao objetivo de permitir testes r√°pidos e integra√ß√£o f√°cil.
Em ambientes de produ√ß√£o, recomenda-se fortemente:

- Implementar autentica√ß√£o robusta (JWT, OAuth2 ou similar) para proteger todos os endpoints sens√≠veis.

- Configurar CORS de forma restritiva, permitindo apenas dom√≠nios confi√°veis.

- Aplicar rate limiting para evitar abusos e ataques de for√ßa bruta.

- Utilizar sempre HTTPS em ambientes p√∫blicos.

- Definir permiss√µes e regras de acesso adequadas para cada recurso.

- Nunca expor dados sens√≠veis em respostas ou logs.

- Manter todos os pacotes e depend√™ncias atualizados.

- Monitorar e registrar tentativas de acesso n√£o autorizado e erros cr√≠ticos.

---

## ‚ö° Performance e Escalabilidade

- O projeto utiliza Django e PostgreSQL, tecnologias robustas e amplamente utilizadas em aplica√ß√µes de miss√£o cr√≠tica.
- Para ambientes de produ√ß√£o, recomenda-se:
  - Utilizar servidores WSGI/ASGI perform√°ticos (ex: Gunicorn, Uvicorn) atr√°s de um proxy reverso (ex: Nginx).
  - Configurar connection pool do banco de dados para suportar m√∫ltiplas conex√µes simult√¢neas.
  - Ativar cache (Redis/Memcached) para respostas e consultas frequentes.
  - Habilitar compress√£o de respostas HTTP para otimizar o tr√°fego de dados da API.
  - Monitorar m√©tricas de uso, lat√™ncia e erros com ferramentas como Prometheus, Grafana, Sentry ou APM.
  - Escalar horizontalmente via containers/Docker Swarm/Kubernetes conforme a demanda.
  - Implementar rate limiting para evitar abusos e proteger recursos.
  - Pagina√ß√£o de queries: Para endpoints que podem retornar muitos registros, implementar pagina√ß√£o (limit/offset ou cursor-based). Isso garante respostas r√°pidas, uso eficiente de recursos e melhor experi√™ncia para o consumidor da API. O Django REST Framework j√° oferece suporte nativo a pagina√ß√£o configur√°vel.
  - Testes de carga e stress.

---

## üåê Deploy AWS & CI/CD Pipeline (Diferencial)

Este projeto est√° **implantado automaticamente na AWS EC2** via pipeline CI/CD (GitHub Actions), utilizando Docker e banco PostgreSQL gerenciado na AWS RDS. Todo o processo segue padr√µes profissionais de DevOps e infraestrutura como c√≥digo.

### üîó API Online para Testes

Voc√™ pode interagir com a API em tempo real. Exemplos:

- [Dashboard consolidado](http://44.207.252.93:8000/api/dashboard/)
- [Produtores](http://44.207.252.93:8000/api/produtores/)
- [Documenta√ß√£o OpenAPI (Swagger)](http://44.207.252.93:8000/api/docs/)

### üöÄ Pipeline de Deploy (GitHub Actions)

- **Testes automatizados:** Cada push no `main` executa testes unit√°rios e de integra√ß√£o.
- **Deploy seguro:** O c√≥digo √© enviado via SSH para a EC2, onde o pipeline:
  - Atualiza o c√≥digo-fonte.
  - Gera o arquivo `.env` de produ√ß√£o a partir de secrets do GitHub (com prote√ß√£o para caracteres especiais).
  - Sobe os containers Docker em modo produ√ß√£o (`gunicorn`).
  - Executa migra√ß√µes e seed do banco via containers ef√™meros, garantindo consist√™ncia e idempot√™ncia.
  - Exibe logs de erro automaticamente em caso de falha.
- **Containers tempor√°rios s√£o removidos automaticamente** ap√≥s comandos administrativos, mantendo o ambiente limpo.

### ‚òÅÔ∏è Infraestrutura AWS

- **EC2:** Inst√¢ncia Linux com Docker, configurada com Elastic IP para endpoint p√∫blico est√°vel.
- **RDS PostgreSQL:** Banco de dados gerenciado, seguro e escal√°vel.
- **Seguran√ßa:** Grupos de seguran√ßa configurados para acesso restrito entre EC2 e RDS.
- **Vari√°veis sens√≠veis:** Gerenciadas via GitHub Secrets, nunca expostas no reposit√≥rio.
- **Gunicorn:** Servidor WSGI robusto, otimizado para produ√ß√£o.

### üèÜ Destaques do pipeline e infraestrutura

- **Zero downtime:** Deploys n√£o derrubam a API.
- **Logs e troubleshooting facilitados:** Logs acess√≠veis via pipeline e SSH.
- **Pronto para avalia√ß√£o t√©cnica:** O c√≥digo, a infraestrutura e o pipeline seguem padr√µes de mercado, facilitando auditoria e evolu√ß√£o.

> **Nota sobre ambiente de testes:**
> Para facilitar a avalia√ß√£o e o acesso p√∫blico, o CORS est√° aberto para qualquer origem.
> O deploy AWS n√£o utiliza proxy reverso e n√£o est√° configurado com HTTPS.
> **Em ambientes de produ√ß√£o**, recomenda-se fortemente:
> - Utilizar proxy reverso (Nginx/Traefik).
> - Habilitar HTTPS com certificados v√°lidos.
> - Restringir o CORS apenas para dom√≠nios confi√°veis.
> - Adotar pr√°ticas adicionais de seguran√ßa e performance.

---

## ‚ùì FAQ

**Por que a API n√£o exige autentica√ß√£o?**  
Para facilitar testes e avalia√ß√£o, mas est√° pronta para receber JWT/OAuth2 em produ√ß√£o.

**Como rodar os testes?**  
Veja a se√ß√£o de testes acima ou execute `docker-compose exec app pytest --cov`.

---

## üìö Refer√™ncias

- [Django REST Framework](https://www.django-rest-framework.org/)
- [12 Factor App](https://12factor.net/)
- [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html)

---

## üë§ Autor

- [Francisco Ricardo Taborda Aguiar](https://github.com/francisco-ricardo)
- Contato: franciscoricardo.dev@gmail.com
- [LinkedIn](https://www.linkedin.com/in/francisco-ricardo-taborda-aguiar-3ab650a0/)

---

## üìù Licen√ßa

Este projeto est√° licenciado sob a licen√ßa MIT.

---